{"version":3,"sources":["components/MeetingFooter/MeetingFooter.component.js","components/card/Card.component.js","components/Participants/Participant/Participant.component.js","components/Participants/Participants.component.js","store/actiontypes.js","store/actioncreator.js","components/MainScreen/MainScreen.component.js","server/firebase.js","App.js","reportWebVitals.js","server/peerConnection.js","store/reducer.js","index.js"],"names":["MeetingFooter","props","_useState","useState","mic","video","screen","_useState2","_slicedToArray","streamState","setStreamState","setScreenState","isEnabled","currentState","_objectSpread","useEffect","onMicClick","onVideoClick","_jsxs","className","children","_jsx","onClick","FontAwesomeIcon","icon","faMicrophone","faMicrophoneSlash","title","faVideo","faVideoSlash","onScreenClick","disabled","faDesktop","ReactTooltip","Card","Participant","curentIndex","currentParticipant","hideVideo","videoRef","showAvatar","currentUser","concat","ref","id","autoPlay","playsInline","audio","style","background","avatarColor","name","_Fragment","connect","state","participants","stream","mainStream","useRef","participantKey","Object","keys","current","srcObject","muted","values","gridCol","length","gridColSize","gridRowSize","Math","ceil","screenPresenter","find","element","map","index","pc","peerConnection","remoteStream","MediaStream","ontrack","event","streams","getTracks","forEach","track","addTrack","videElement","document","getElementById","SET_MAIN_STREAM","ADD_PARTICIPANT","REMOVE_PARTICIPANT","SET_USER","UPDATE_USER","UPDATE_PARTICIPANT","setMainStream","type","payload","dispatch","updateUser","user","participantRef","updateStream","key","sender","getSenders","s","kind","replaceTrack","getVideoTracks","onScreenShareEnd","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","localStream","wrap","_context","prev","next","navigator","mediaDevices","getUserMedia","sent","enabled","getAudioTracks","stop","apply","arguments","_ref2","_callee2","mediaStream","_context2","getDisplayMedia","mediaSource","onended","Participants","micEnabled","videoEnabled","class","firebase","initializeApp","databaseURL","apiKey","authDomain","projectId","storageBucket","messagingSenderId","appId","auth","db","firepadRef","storage","database","username","requiredPrompt","prompt","replace","userName","roomId","URLSearchParams","window","location","search","get","child","push","history","replaceState","addParticipant","newUser","setUser","removeParticipant","userId","updateParticipant","getUserStream","abrupt","connectedRef","on","snap","val","defaultPreference","userStatusRef","preferences","_defineProperty","onDisconnect","remove","isUserSet","isStreamSet","preferenceSnap","_snap$val","_snap$val$preferences","MainScreen","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","createOffer","receiverId","createdID","currentParticipantRef","offerDescription","offer","onicecandidate","candidate","toJSON","setLocalDescription","sdp","set","_x","_x2","_x3","initializeListensers","_callee3","currentUserRef","_context3","_ref3","snapshot","data","store","getState","setRemoteDescription","RTCSessionDescription","createAnswer","_x5","addIceCandidate","RTCIceCandidate","answer","answerDescription","_x4","_ref4","_callee4","otherUserId","participantRef1","_context4","_x6","_x7","defaultUserState","servers","iceServers","urls","iceCandidatePoolSize","generateColor","floor","random","toString","addConnection","RTCPeerConnection","newUserId","currentUserId","offerIds","sort","a","b","localeCompare","createStore","undefined","action","preference","setTimeout","update","updatePreference","ReactDOM","render","React","StrictMode","Provider","App"],"mappings":"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","file":"static/js/main.4272b1e1.chunk.js","sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  faMicrophone,\n  faVideo,\n  faDesktop,\n  faVideoSlash,\n  faMicrophoneSlash,\n  faEnvelope,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport ReactTooltip from \"react-tooltip\";\nimport \"./MeetingFooter.css\";\nconst MeetingFooter = (props) => {\n  // streamState is initialized as an object with three properties: 'mic', 'video', and 'screen', each of which is assigned an initial boolean value.\n  const [streamState, setStreamState] = useState({\n    mic: true,\n    video: false,\n    screen: false,\n  });\n  //  When 'micClick' is called, it toggles the microphone state in the streamState object, ensuring that the microphone can be turned on and off within the React component by calling this function. The setStreamState function ensures that the component re-renders with the updated state, reflecting any changes in the UI.\n  const micClick = () => {\n    setStreamState((currentState) => {\n      return {\n        // the spread operator ({ ...currentState }) is used to create a shallow copy of the current state object. The spread operator is used to create a new object with the same properties as the currentState object. This is done to ensure that we don't directly mutate the state object, which is a best practice in React.\n        ...currentState,\n        mic: !currentState.mic,\n      };\n    });\n  };\n\n  // Similarly for 'onVideoClick'\n  const onVideoClick = () => {\n    setStreamState((currentState) => {\n      return {\n        ...currentState,\n        video: !currentState.video,\n      };\n    });\n  };\n\n  // Related to enabling or disabling screen sharing\n  const onScreenClick = () => {\n    props.onScreenClick(setScreenState);\n  };\n  // 'setScreenState', it uses the 'setStreamState' function, which is a React state updater function (from useState). It updates the state by creating a new object using the spread syntax (...currentState) to copy(Shallow) the existing state and then overrides the screen property with the value of isEnabled.\n  const setScreenState = (isEnabled) => {\n    setStreamState((currentState) => {\n      return {\n        ...currentState,\n        screen: isEnabled,\n      };\n    });\n  };\n\n  // monitoring changes in the 'streamState.mic' value, as indicated by the dependency array [streamState.mic]. When the 'streamState.mic' value changes (i.e., when the microphone state is toggled), this effect is triggered. It then calls 'props.onMicClick'.(streamState.mic)\n  useEffect(() => {\n    props.onMicClick(streamState.mic);\n  }, [streamState.mic]);\n\n  //  monitoring changes in the 'streamState.video' value, indicated by the [streamState.video] dependency array. When the 'streamState.video' value changes (i.e., when the video state is toggled), this effect is triggered. It then calls         'props.onVideoClick(streamState.video)'.\n  useEffect(() => {\n    props.onVideoClick(streamState.video);\n  }, [streamState.video]);\n\n  \n  return (\n    <div className=\"meeting-footer\">\n      <div\n        className={\"meeting-icons \" + (!streamState.mic ? \"active\" : \"\")}\n        data-tip={streamState.mic ? \"Mute Audio\" : \"Unmute Audio\"}\n        onClick={micClick}\n      >\n        <FontAwesomeIcon\n          icon={!streamState.mic ? faMicrophoneSlash : faMicrophone}\n          title=\"Mute\"\n        />\n      </div>\n      <div\n        className={\"meeting-icons \" + (!streamState.video ? \"active\" : \"\")}\n        data-tip={streamState.video ? \"Hide Video\" : \"Show Video\"}\n        onClick={onVideoClick}\n      >\n        <FontAwesomeIcon icon={!streamState.video ? faVideoSlash : faVideo} />\n      </div>\n      <div\n        className=\"meeting-icons\"\n        data-tip=\"Share Screen\"\n        onClick={onScreenClick}\n        disabled={streamState.screen}\n      >\n        <FontAwesomeIcon icon={faDesktop} />\n      </div>\n      <ReactTooltip />\n    </div>\n  );\n};\n\nexport default MeetingFooter;","import React from \"react\";\nimport \"./Card.css\";\n\nconst Card = (props) => {\n  return <div className=\"card\">{props.children}</div>;\n};\n\nexport default Card;\n","import React from \"react\";\nimport Card from \"../../card/Card.component\";\nimport { faMicrophoneSlash } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport \"./Participant.css\";\n\nexport const Participant = (props) => {\n\n  const {\n    curentIndex,\n    currentParticipant,\n    hideVideo,\n    videoRef,\n    showAvatar,\n    currentUser,\n  } = props;\n  // If there is no currentParticipant (possibly when a participant leaves the meeting), the component returns an empty fragment (<></>), effectively rendering nothing.\n  if (!currentParticipant) return <></>;\n  return (\n    <div className={`participant ${hideVideo ? \"hide\" : \"\"}`}>\n      <Card>\n        <video\n        //The 'ref' attribute in React is used to create a reference to a DOM (Document Object Model) element, such as an HTML element like a video element in this case.\n          ref={videoRef}  //'ref={videoRef}': reference to the <video> element using the 'videoRef' prop passed to the Participant component. This allows you to access and manipulate the properties and methods of this specific video element elsewhere in your code.\n          className=\"video\"\n          id={`participantVideo${curentIndex}`} // Set the unique HTML id attribute of the video element\n          autoPlay\n          playsInline\n        ></video>\n\n        {/* Display a muted microphone icon if 'currentParticipant.audio' is false */}\n        {!currentParticipant.audio && (\n          <FontAwesomeIcon\n            className=\"muted\"\n            icon={faMicrophoneSlash}\n            title=\"Muted\"\n          />\n        )}\n        {showAvatar && (\n          <div\n            style={{ background: currentParticipant.avatarColor }} //Set the background color based on participant's avatarColor which is generated in store>reducer.js\n            className=\"avatar\"\n          >\n            {currentParticipant.name[0]} \n            {/* // Display the first character of the participant's name as the avatar. */}\n          </div>\n        )}\n        <div className=\"name\">         \n        {/* // Display the participant's name */}\n          {currentParticipant.name}\n          {currentUser ? \"(You)\" : \"\"} \n          {/* // If currentUser is true, display \"(You)\" next to the name */}\n        </div>\n      </Card>\n    </div>\n  );\n};\n\n\n\n\n\n","import React, { useEffect, useRef } from \"react\";\nimport \"./Participants.css\";\nimport { connect } from \"react-redux\";\nimport { Participant } from \"./Participant/Participant.component\";\n\nconst Participants = (props) => {\n  // Create a reference for the video element\n  const videoRef = useRef(null);\n  // Get an array of participant keys from the Redux store\n  let participantKey = Object.keys(props.participants);\n  // To update the video element when currentUser or stream changes\n  useEffect(() => {\n    if (videoRef.current) {\n      videoRef.current.srcObject = props.stream;\n      videoRef.current.muted = true;\n    }\n  }, [props.currentUser, props.stream]);\n  // Extract the currentUser object from props\n  const currentUser = props.currentUser\n    ? Object.values(props.currentUser)[0]\n    : null;\n  // Determine the grid layout based on the number of participants\n  let gridCol =\n    participantKey.length === 1 ? 1 : participantKey.length <= 4 ? 2 : 4;\n  const gridColSize = participantKey.length <= 4 ? 1 : 2;\n  let gridRowSize =\n    participantKey.length <= 4\n      ? participantKey.length\n      : Math.ceil(participantKey.length / 2);\n\n  // Check if there's a participant presenting their screen\n  const screenPresenter = participantKey.find((element) => {\n    const currentParticipant = props.participants[element];\n    return currentParticipant.screen;\n  });\n\n  // Adjust grid layout if there's a screen presenter\n  if (screenPresenter) {\n    gridCol = 1;\n    gridRowSize = 2;\n  }\n\n  // Map participant data to Participant components\n  // Maps through each participant in participantKey and creates a Participant component for each one. It also checks if the participant is the current user and returns null in that case to skip rendering their own video.\n  // 'element' represents the current element (or value) in the array participantKey \n  // 'index' represents the index of the current element within the participantKey array as the map function iterates through it. It starts at 0 for the first element, 1 for the second element, and so on.\n  // It creates an array of participants by mapping over the participantKey array. For each element in participantKey, it generates a <Participant /> component with specific props.\n  const participants = participantKey.map((element, index) => {\n    const currentParticipant = props.participants[element];\n    const isCurrentUser = currentParticipant.currentUser;\n    if (isCurrentUser) {\n      return null;\n    }\n    // Create a new MediaStream for each remote participant\n    // For each remote participant, this code sets up a peerConnection object (pc) and creates a new MediaStream called remoteStream.\n    // The 'peerConnection' object is essential in WebRTC-based applications like video conferencing. It handles the communication and exchange of media streams (video, audio) between participants. In this case, it's used to receive and display the video and audio from the remote participant.\n    const pc = currentParticipant.peerConnection;\n    // 'remoteStream' will hold the remote participant's audio and video.\n    const remoteStream = new MediaStream();  \n    // 'curentIndex' to keep track of the index of the current participant.\n    let curentIndex = index;\n\n\n    // Add remote tracks to the remoteStream\n    // It registers an ontrack event handler for the peer connection. When remote tracks (audio or video) are received, they are added to the remoteStream.\n    // It then updates the video element (with the ID \"participantVideoX\") to display the remote stream.\n\n    // checking if there's a peerConnection object (pc) for the current remote participant.\n    // \"current remote participant\" refers to the participant currently being processed in the loop that iterates over the list of participants. The loop goes through each participant in the participantKey array, and currentParticipant represents the details and state of the participant being processed during each iteration.\n    if (pc) {\n      // set up an ontrack event handler for the peerConnection. This event handler is triggered when the remote participant's audio or video tracks are received.\n      /* \n      When tracks arrive, the code does the following:\n      It iterates through each track received (audio or video).\n      For each track, it adds the track to the remoteStream, so the stream now contains both audio and video tracks from the remote participant. */\n      pc.ontrack = (event) => {\n        event.streams[0].getTracks().forEach((track) => {\n          remoteStream.addTrack(track);\n        });\n        // Update the video element with the remote stream\n        // Retrieves the HTML video element associated with the current remote participant, using the currentIndex.\n        const videElement = document.getElementById(\n          `participantVideo${curentIndex}`\n        );\n        // If the 'videElement' exists, it sets the 'srcObject' property of the video element to the 'remoteStream'. In simpler terms, it tells the video element to display the video content provided by the 'remoteStream'(contains the video and audio tracks received from a remote participant).\n        if (videElement) videElement.srcObject = remoteStream;\n      };\n    }\n\n\n    // Render the Participant component with specific prop\n    return (\n      <Participant\n        key={curentIndex}\n        currentParticipant={currentParticipant}\n        curentIndex={curentIndex}\n        hideVideo={screenPresenter && screenPresenter !== element}\n        showAvatar={\n          !currentParticipant.video &&\n          !currentParticipant.screen &&\n          currentParticipant.name\n        }\n      />\n    );\n  });\n\n\n  // Render the container for all Participant components\n  return (\n    <div\n      style={{\n        \"--grid-size\": gridCol,\n        \"--grid-col-size\": gridColSize,\n        \"--grid-row-size\": gridRowSize,\n      }}\n      className={`participants`}\n    >\n      {participants}\n      <Participant\n        currentParticipant={currentUser}\n        curentIndex={participantKey.length}\n        hideVideo={screenPresenter && !currentUser.screen}\n        videoRef={videoRef}\n        showAvatar={currentUser && !currentUser.video && !currentUser.screen}\n        currentUser={true}\n      />\n    </div>\n  );\n};\n\n// 'mapStateToProps' function is used in a React-Redux application to map the state from the Redux store to props that can be used within a component.\n// 'state' is the parameter representing the current state of the Redux store.\n// mapStateToProps function allows the connected component to access specific pieces of data (participants, currentUser, and stream) from the Redux store's state by mapping them to corresponding props. These props can then be used within the component to access and display this data as needed.\nconst mapStateToProps = (state) => {\n  return {\n    // Ihe 'participants' property from the Redux state available as a prop named 'participants' in your component. So, your component can access this data as this.props.participants.\n    participants: state.participants,\n    currentUser: state.currentUser,\n    stream: state.mainStream,\n  };\n};\n\n// 'export default connect(mapStateToProps)(Participants);' is using the connect function provided by the react-redux library to connect a React component, in this case, Participants, to the Redux store.\nexport default connect(mapStateToProps)(Participants);\n// Basically it connects your 'Participants' component to a magical storage (Redux store) where your app keeps important data. It also provides a way for 'Participants' to send requests fetch(no change as we have no dispact) that data.\n","// action types are typically used in Redux to specify the type of action that should be performed when you dispatch an action.\n// These action types are used in your Redux actions to specify the type of action you want to perform. When you dispatch an action with one of these types, your Redux reducers will respond to these actions and update the state in your Redux store accordingly.\nexport const SET_MAIN_STREAM = \"SET_MAIN_STREAM\";\nexport const ADD_PARTICIPANT = \"ADD_PARTICIPANT\";\nexport const REMOVE_PARTICIPANT = \"REMOVE_PARTICIPANT\";\nexport const SET_USER = \"SET_USER\";\nexport const UPDATE_USER = \"UPDATE_USER\";\nexport const UPDATE_PARTICIPANT = \"UPDATE_PARTICIPANT\";\nexport const SET_MESSAGES = \"SET_MESSAGES\"","import {\n  SET_MAIN_STREAM,\n  ADD_PARTICIPANT,\n  SET_USER,\n  REMOVE_PARTICIPANT,\n  UPDATE_USER,\n  UPDATE_PARTICIPANT,\n  SET_MESSAGES,\n} from \"./actiontypes\";\n\n// export const setMainStream = (stream) => { ... }: This line exports a function called 'setMainStream'. It's a named export, which means you can import and use this function in other parts of your code.\nexport const setMainStream = (stream) => {\n  return {\n    // action object\n    // 'type: SET_MAIN_STREAM': This specifies the type of action you are performing. In this case, it's set to 'SET_MAIN_STREAM', which corresponds to the action type you defined earlier in your 'actionTypes.js' file.\n    type: SET_MAIN_STREAM,\n    //  The payload property of the action object typically contains data associated with the action. Here, you're passing the 'stream' as the 'mainStream' property within the payload. This allows you to update the main video stream in your Redux store with the provided 'stream'.\n    payload: {\n      mainStream: stream,\n    },\n  };\n};\n\nexport const setUser = (user) => {\n  return {\n    type: SET_USER,\n    payload: {\n      currentUser: user,\n    },\n  };\n};\n\nexport const addParticipant = (user) => {\n  return {\n    type: ADD_PARTICIPANT,\n    payload: {\n      newUser: user,\n    },\n  };\n};\n\nexport const updateUser = (user) => {\n  return {\n    type: UPDATE_USER,\n    payload: {\n      currentUser: user,\n    },\n  };\n};\n\nexport const updateParticipant = (user) => {\n  return {\n    type: UPDATE_PARTICIPANT,\n    payload: {\n      newUser: user,\n    },\n  };\n};\n\nexport const removeParticipant = (userId) => {\n  return {\n    type: REMOVE_PARTICIPANT,\n    payload: {\n      id: userId,\n    },\n  };\n};\n\nexport const setMessages = (messages) => {\n  return {\n    type: SET_MESSAGES,\n    payload:{\n      message:messages,\n    }\n  };\n};\n\n","import React, { useRef, useEffect } from \"react\";\nimport MeetingFooter from \"../MeetingFooter/MeetingFooter.component\";\nimport Participants from \"../Participants/Participants.component\";\nimport \"./MainScreen.css\";\nimport { connect } from \"react-redux\";\nimport { setMainStream, updateUser } from \"../../store/actioncreator\";\n\n//  Functional component named 'MainScreen' that takes props as its parameter.\nconst MainScreen = (props) => {\n  // Creates a ref called participantRef initialized with the props.participants value. This ref will be used to store a reference to the participants.\n  const participantRef = useRef(props.participants);\n\n  // 'onMicClick' function that toggles the microphone's audio on or off based on the micEnabled parameter.\n  const onMicClick = (micEnabled) => {\n    // props.stream is an object containing the user's audio and video stream for a video call.\n    if (props.stream) {\n      // Accessing the first element ([0]) of the audio tracks is a common practice when dealing with audio and video tracks in WebRTC, because we just targeting the audio stream coming from the user's microphone, not any other audio sources like the screen, etc.\n      props.stream.getAudioTracks()[0].enabled = micEnabled;\n      props.updateUser({ audio: micEnabled });\n    }\n  };\n  //  'onVideoClick' function that toggles the user's video on or off based on the videoEnabled parameter.\n  const onVideoClick = (videoEnabled) => {\n    if (props.stream) {\n      // We access the first element [0] of this array because typically, in a video call scenario, there is only one video track, representing the user's camera feed. By accessing the first element, we are effectively targeting the user's camera feed.\n      props.stream.getVideoTracks()[0].enabled = videoEnabled;\n      props.updateUser({ video: videoEnabled });\n    }\n  };\n// 'useEffect' hook to update the participantRef.current whenever the props.participants change.\n  useEffect(() => {\n    participantRef.current = props.participants;\n  }, [props.participants]);\n\n  const updateStream = (stream) => {\n    // Loop through each participant in `participantRef.current`\n    for (let key in participantRef.current) {\n    // Get the sender object for the current participant\n      const sender = participantRef.current[key];\n    // Check if the current participant is the currentUser, and if so, skip to the next participant\n      if (sender.currentUser) continue;\n    // Get the peerConnection object for the current participant and find the sender associated with video tracks\n      const peerConnection = sender.peerConnection\n        .getSenders()\n        .find((s) => (s.track ? s.track.kind === \"video\" : false));\n      //finds the sender that is associated with video tracks It then replaces the video track in the sender with the video track from the stream parameter. This effectively updates the video being sent by that participant with the latest video track from the 'stream'. Camera will be in on-status but when the user toggles the camera to on then only we send the video stream.\n\n      // ******** SCOPE OF IMPROVEMENT == Only on camera when user toggels camera to on ******* //\n      peerConnection.replaceTrack(stream.getVideoTracks()[0]);\n    }\n    // Set the main video stream to the `stream` parameter\n    props.setMainStream(stream);\n  };\n  //Handle ending a screen sharing session.\n  /*It stops the user's screen sharing video stream and restores their camera video stream based on the value in props.currentUser.\nIt then updates the video stream that is being sent to other participants (likely using the updateStream function).\nFinally, it updates the user's status to indicate that screen sharing is no longer active.*/\n  const onScreenShareEnd = async () => {\n    // 'navigator.mediaDevices.getUserMedia' method to request access to the user's media devices, specifically audio and video.\n    // 'localStream' that represents the user's audio and video stream, which will be used when screen sharing ends.\n    const localStream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: true,\n    });\n\n    localStream.getVideoTracks()[0].enabled = Object.values(\n      props.currentUser\n    )[0].video;\n    localStream.getAudioTracks()[0].enabled = Object.values(\n      props.currentUser\n    )[0].audio;\n    updateStream(localStream);\n    // to update the user's status,indicating that the screen sharing session has ended.\n    props.updateUser({ screen: false });\n  };\n  // Start a screen sharing session\n  /* It checks for compatibility with different screen sharing methods.\n    It obtains the user's screen sharing media stream.\n    It sets an event handler to detect when the screen sharing session ends.\n    It updates the video stream that is being sent to others or updates the user's own video feed.\n    It updates the user's status to indicate that they are screen sharing. */\n  const onScreenClick = async () => {\n    // 'mediaStream'  will store the user's screen sharing media stream.\n    let mediaStream;\n    // ***Screen Sharing Method Selection***\n    //The code checks for different methods of obtaining a screen sharing stream, depending on the browser's compatibility.\n    // Which ever method is available that is used for sharing screen.\n    // Depending on the method available, the code awaits the user's permission to access the screen sharing media stream.\n    if (navigator.getDisplayMedia) {\n      mediaStream = await navigator.getDisplayMedia({ video: true });\n    } else if (navigator.mediaDevices.getDisplayMedia) {\n      mediaStream = await navigator.mediaDevices.getDisplayMedia({\n        video: true,\n      });\n    } else {\n      mediaStream = await navigator.mediaDevices.getUserMedia({\n        video: { mediaSource: \"screen\" },\n      });\n    }\n    //  Set an event handler for the 'onended' event of the first video track in the mediaStream. This event handler is set to a function called 'onScreenShareEnd'. It's used to detect when the screen sharing session ends.\n    mediaStream.getVideoTracks()[0].onended = onScreenShareEnd;\n    //  Updates the video stream that is being sent to other participants or updates the user's own video feed with the screen sharing stream.\n    updateStream(mediaStream);\n    //  Used to update the user's status to indicate that they are currently screen sharing.\n    props.updateUser({ screen: true });\n  };\n  return (\n    <div className=\"wrapper\">\n      <div className=\"mainScreen\">\n        <Participants />\n      </div>\n\n      <div className=\"footer\">\n        <MeetingFooter\n          onScreenClick={onScreenClick}\n          onMicClick={onMicClick}\n          onVideoClick={onVideoClick}\n        />\n      </div>\n      <div class=\"main__right\">\n      <div class=\"main__chat_window\">\n          <div class=\"messages\">\n\n          </div>\n      </div>\n    </div>\n    </div>\n  );\n};\n// This function is used to map specific parts of the Redux state to the props of a React component i.e 'mapStateToProps' is used when connecting a React component to the Redux store and you're specifying which parts of the store's state should be accessible to your component as props. This makes it easy for your component to access and display the data it needs from the Redux store.\n// 'state' represents the Redux state object.\nconst mapStateToProps = (state) => {\n  return {\n    // Ihe mainStream property from the Redux state available as a prop named stream in your component. So, your component can access this data as this.props.stream.\n    stream: state.mainStream,\n    participants: state.participants,\n    currentUser: state.currentUser,\n  };\n};\n// This allows the connected component to access the 'mainStream','participants','currentUser' property from the Redux store.\n\n\n// The 'mapDispatchToProps' function is used in a Redux-connected component to specify what actions should be available as props in that component.\n// 'dispatch'  parameter is a function provided by Redux that allows you to dispatch actions to update the state in the Redux store.\n// The function's return value is an object that you define. Each property in this object corresponds to a prop that you want to make available to your React component, and the property's value is a function that dispatches a specific action.\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    // Creates a prop named 'setMainStream' in your component. When you call 'this.props.setMainStream(stream)' in your component, it dispatches the setMainStream action with the stream argument. This action typically updates the mainStream property in the Redux store.\n    setMainStream: (stream) => dispatch(setMainStream(stream)),\n    // When you call this.props.updateUser(user) in your component, it dispatches the updateUser action with the user argument. This action is used to update the user-related data in the Redux store.\n    updateUser: (user) => dispatch(updateUser(user)),\n  };\n};\n// mapDispatchToProps, you're allowing your React component to dispatch specific actions that can update the Redux store. This is crucial for managing and maintaining the application's state in a centralized manner.\n\n\n\n// connecting 'MainScreen' React component to a Redux store, allowing it to access data from the store's state and dispatch actions to update that state.\n// 'connect(mapStateToProps, mapDispatchToProps)' is a function provided by the react-redux library that connects your React component to the Redux store. It takes two functions as arguments: 'mapStateToProps' specifies which data from the store's state should be available as props in MainScreen and 'mapDispatchToProps' specifies which actions can be triggered from MainScreen to update the store.\n// Then pass your 'MainScreen' component as an argument to connect. By this we \"wrap\" your component with Redux functionality\nexport default connect(mapStateToProps, mapDispatchToProps)(MainScreen);\n\n// Basically it connects your MainScreen component to a magical storage (Redux store) where your app keeps important data. It also provides a way for MainScreen to send requests to change or fetch that data.\n\n// 'mapStateToProps' is primarily for reading data from the store, and if you want to dispatch actions to change the store, you would need to use 'mapDispatchToProps'.","import firebase from \"firebase\";\nimport \"firebase/auth\";\nimport \"firebase/firestore\";\n\n// object contains configuration settings for connecting to Firebase\n// {more details below}\nvar firebaseConfig = {\n  databaseURL:\"https://myntra-meet-default-rtdb.firebaseio.com/\", // Add databaseURL,\n  apiKey: \"AIzaSyCG2MzwPgvcgy5qkGKLy4k-7nXrUtHnd2E\",\n  authDomain: \"myntra-meet.firebaseapp.com\",\n  projectId: \"myntra-meet\",\n  storageBucket: \"myntra-meet.appspot.com\",\n  messagingSenderId: \"314285805616\",\n  appId: \"1:314285805616:web:fbf5377129894c35549df5\"\n};\n// Initialize Firebase\n// Initializes the Firebase SDK with the configuration settings specified in the firebaseConfig object. It tells Firebase how to connect to your Firebase project, including which project to use and the associated authentication credentials.\nfirebase.initializeApp(firebaseConfig);\n// exports the Firebase Authentication service. Firebase Authentication allows you to manage user authentication and provides features like sign-up, sign-in, password reset, and user management. By exporting 'auth', you can use it to handle user authentication within your application.\nexport const auth = firebase.auth();\n// exports the entire Firebase SDK instance. It means you can use db to access various Firebase services, including the Realtime Database, Cloud Firestore, and more. It provides a convenient way to access Firebase services without having to import them individually.\nexport const db = firebase;\n// exports the Firebase Cloud Storage service. Firebase Cloud Storage is used to store and retrieve files and media assets in the cloud. By exporting storage, you can interact with Firebase Cloud Storage to upload, download, and manage files within your app.\nexport const storage = firebase.storage();\n// initializes a reference to the Firebase Realtime Database. The 'firebase.database().ref()' method returns a reference to the root of the database. This reference is stored in the firepadRef variable and can be used to interact with the database.\nvar firepadRef = firebase.database().ref();\n\nlet username = \" \";\n\n// Prompt dialog that asks the user for their name using prompt(). If the user provides an empty name (including whitespace characters) or clicks Cancel, the function will call itself recursively until a valid name is provided.\nfunction requiredPrompt() {\n        username = prompt(\"What's your name?\");\n        if(username==null||username.replace(/\\s/g,\"\") === \"\"){\n          requiredPrompt();\n        }\n    }\nrequiredPrompt();\n\n// removes any whitespace characters from the 'username' string. It uses a regular expression (regex) to find and replace all whitespace characters globally (the g flag) with an empty string.\nusername=username.replace(/\\s/g,\"\");\n\n//  'username' variable as a constant named 'userName'. It makes the userName value available for use in other parts of your application by importing it.\nexport const userName = username;\n// creates a new 'URLSearchParams' object based on the current URL's query parameters. It allows you to easily access and manipulate the query parameters in the URL.\nconst urlparams = new URLSearchParams(window.location.search);\n// extracts the value of the \"id\" query parameter from the URL and stores it in the roomId variable, which can be useful for identifying specific rooms or resources.\nconst roomId = urlparams.get(\"id\");\n\nif (roomId) {\n  // if roomId already exists then to move our reference pointer (firepadRef) to a specific location in the database identified by roomId.\n  firepadRef = firepadRef.child(roomId);\n} else {\n  // If roomId is falsy (likely indicating that the user is creating a new room), this line generates a new unique child reference using Firebase's push() method. This creates a new node in the database with a unique key, effectively creating a new room or document.\n  firepadRef = firepadRef.push();\n  // 'window.history.replaceState(null, \"Meet\", \"?id=\" + firepadRef.key);': This line updates the browser's URL using the HTML5 History API. It replaces the current URL state with a new URL that includes the id parameter, set to the key of the newly generated child reference. This step ensures that users can share the URL with others, allowing them to access the same collaborative document or room.\n  window.history.replaceState(null, \"Meet\", \"?id=\" + firepadRef.key);\n}\n//  exports the 'firepadRef' variable, which now points to either an existing room's Firebase reference or a newly created one.\nexport default firepadRef;\n\n\n\n\n\n\n\n\n\n// ******** Firebase configuration settings ********* //\n/*\n\ndatabaseURL: This property specifies the URL of the Firebase Realtime Database that your application will use. In this case, it's set to \"https://myntra-meet-default-rtdb.firebaseio.com/\". The Realtime Database is a NoSQL, cloud-hosted database that allows you to store and sync data in real-time across clients.\n\napiKey: This property stores an API key that is used for authenticating requests to Firebase services from your web application. It's important to keep this API key secure, as it grants access to your Firebase project.\n\nauthDomain: This property specifies the domain associated with Firebase Authentication. It's used for configuring user authentication and sign-in.\n\nprojectId: The Firebase project ID uniquely identifies your Firebase project. This ID is associated with various Firebase services, such as the Realtime Database and Cloud Storage.\n\nstorageBucket: If you use Firebase Cloud Storage to store and serve user-generated content, this property specifies the storage bucket associated with your project.\n\nmessagingSenderId: This property is used for Firebase Cloud Messaging (FCM) and push notifications. It identifies the sender of messages to devices.\n\nappId: The Firebase project's unique application ID. This identifier is associated with your specific application within the Firebase project.\n\n*/","import MainScreen from \"./components/MainScreen/MainScreen.component\";\nimport firepadRef, { db, userName } from \"./server/firebase\";\nimport \"./App.css\";\nimport React,{ useEffect } from \"react\";\nimport {\n  setMainStream,\n  addParticipant,\n  setUser,\n  removeParticipant,\n  updateParticipant,\n} from \"./store/actioncreator\";\nimport { connect } from \"react-redux\";\n\n// App component initializes media streams, connects to Firebase, and manages participants' preferences and actions based on changes in user and stream availability. It also renders the main content of the application, the MainScreen component.\n// 'props' as parameter, which will be used to access properties and dispatch actions.\nfunction App(props) {\n  // asynchronous function called getUserStream. It uses the navigator.mediaDevices.getUserMedia method to request access to the user's microphone and camera. It returns a localStream representing the user's audio and video stream.\n  const getUserStream = async () => {\n    const localStream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: true,\n    });\n\n    return localStream;\n  };\n  // 'useEffect' hook that runs when the component mounts. \n  useEffect(async () => {\n    // calls the getUserStream function to get the user's media stream and stores it in the stream variable.\n    const stream = await getUserStream();\n    // Disabling the user's video track initially by accessing the first video track in the stream and setting its enabled property to false.\n    stream.getVideoTracks()[0].enabled = false;\n    // props.setMainStream(stream);: Dispatches the setMainStream action with the stream as the payload to set the main stream in the Redux store.\n    props.setMainStream(stream);\n\n    //  It listens to changes in the Firebase '.info/connected' node to detect if the user is connected to the Firebase Realtime Database\n    connectedRef.on(\"value\", (snap) => {\n      if (snap.val()) {\n        //If the user is connected:\n        //It defines a defaultPreference object for user preferences (audio on, video off, screen sharing off).\n        const defaultPreference = {\n          audio: true,\n          video: false,\n          screen: false,\n        };\n        // It pushes user information to the participantRef in Firebase, including their name and default preferences.\n        const userStatusRef = participantRef.push({\n          userName,\n          preferences: defaultPreference,\n        });\n        props.setUser({\n          [userStatusRef.key]: { name: userName, ...defaultPreference },\n        });\n        // It sets an \"onDisconnect\" callback to remove the user's data from Firebase when they disconnect.\n        userStatusRef.onDisconnect().remove();\n      }\n    });\n  }, []);\n  // const connectedRef = db.database().ref(\".info/connected\");: Creates a reference to the Firebase Realtime Database node .info/connected, which is used to check the user's connection status.\n  const connectedRef = db.database().ref(\".info/connected\");\n  // const participantRef = firepadRef.child(\"participants\");: Creates a reference to the Firebase database node where participant data is stored.\n  const participantRef = firepadRef.child(\"participants\");\n\n  // if the 'user' property exists in the component's props and assigns true or false accordingly.\n  const isUserSet = !!props.user;\n  // if the stream property exists in the component's props and assigns true or false accordingly.\n  const isStreamSet = !!props.stream;\n\n  // useEffect hook that runs when either 'isStreamSet' or 'isUserSet' changes. \n  useEffect(() => {\n    if (isStreamSet && isUserSet) {\n      // participantRef.on(\"child_added\", (snap) => { ... }): This event listener triggers when a new participant is added to the \"participants\" node in Firebase. It captures the participant's data snapshot as snap.\n      participantRef.on(\"child_added\", (snap) => {\n        // It creates a reference 'preferenceUpdateEvent' to the \"preferences\" node for the current participant.\n        const preferenceUpdateEvent = participantRef\n          .child(snap.key)\n          .child(\"preferences\");\n        // Listens for the \"child_changed\" event on the \"preferences\" node. When a preference changes, it dispatches the \"updateParticipant\" action with the updated preference.\n        preferenceUpdateEvent.on(\"child_changed\", (preferenceSnap) => {\n          props.updateParticipant({\n            [snap.key]: {\n              [preferenceSnap.key]: preferenceSnap.val(),\n            },\n          });\n        });\n        // Extracting the participant's name and preferences from the data snapshot and assigns them to name and preferences.\n        const { userName: name, preferences = {} } = snap.val();\n        // dispatches the \"addParticipant\" action with an object containing the participant's ID as the key and their name and preferences as the value.\n        props.addParticipant({\n          [snap.key]: {\n            name,\n            ...preferences,\n          },\n        });\n      });\n      // the \"child_removed\" event listener dispatches the \"removeParticipant\" action with the removed participant's ID.\n      participantRef.on(\"child_removed\", (snap) => {\n        props.removeParticipant(snap.key);\n      });\n    }\n  }, [isStreamSet, isUserSet]);\n\n  return (\n    <div className=\"App\">\n      <MainScreen />\n    </div>\n  );\n}\n\n// Maps the state from the Redux store to the props of the connected component (App). It takes the state as its parameter, which represents the current state of the Redux store.\nconst mapStateToProps = (state) => {\n  return {\n    // Maps the 'mainStream' property from the Redux store's state to the stream prop of the App component. This allows the App component to access the user's video stream from the Redux store.\n    stream: state.mainStream,\n    // Maps the 'currentUser' property from the Redux store's state to the user prop of the App component. This provides the App component with information about the current user.\n    user: state.currentUser,\n  };\n};\n\n// Maps action creators to props, allowing the connected component to dispatch Redux actions. It takes dispatch as its parameter, which is a function used to dispatch actions to the Redux store.\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    // Maps the 'setMainStream' action creator to the 'setMainStream' prop. This action is used to set the main video stream in the Redux store.\n    setMainStream: (stream) => dispatch(setMainStream(stream)),\n    //  Maps the 'addParticipant' action creator to the 'addParticipant' prop. This action is used to add a new participant to the Redux store.\n    addParticipant: (user) => dispatch(addParticipant(user)),\n    // Maps the 'setUser' action creator to the 'setUser' prop. This action is used to set user information in the Redux store.\n    setUser: (user) => dispatch(setUser(user)),\n    // Maps the 'removeParticipant' action creator to the 'removeParticipant' prop. This action is used to remove a participant from the Redux store.\n    removeParticipant: (userId) => dispatch(removeParticipant(userId)),\n    // Maps the 'updateParticipant' action creator to the 'updateParticipant' prop. This action is used to update participant information in the Redux store.\n    updateParticipant: (user) => dispatch(updateParticipant(user)),\n  };\n};\n\n// Connect is a higher-order function provided by the react-redux library. It takes two function calls as arguments: mapStateToProps and mapDispatchToProps. The first function, mapStateToProps, specifies how to map the state from the Redux store to the component's props. The second function, mapDispatchToProps, specifies how to map action creators to the component's props.When you call connect(mapStateToProps, mapDispatchToProps)(App), it returns a new component that is connected to the Redux store. This connected component receives the specified props and can dispatch actions.\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n\n// The 'App' component to the Redux store, allowing it to access data from the store (via mapStateToProps) and dispatch actions (via mapDispatchToProps). This connection is established using the connect function from react-redux, making it easier to manage and update application state in response to user interactions and data changes.\n\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import firepadRef from \"./firebase\";\nimport { store } from \"../index\";\n\n// 'const participantRef = firepadRef.child(\"participants\");': Here, a new constant participantRef is created by navigating to a specific location in the Firebase Realtime Database using 'firepadRef'. It goes to the \"participants\" node, which is a child node of the location pointed to by 'firepadRef'. 'participantRef' is now a reference to the \"participants\" node in the database.\nconst participantRef = firepadRef.child(\"participants\");\n\nexport const updatePreference = (userId, preference) => {\n  // creates a new reference 'currentParticipantRef'. It starts from the 'participantRef' and then goes to a specific participant node indicated by 'userId'. From there, it goes further to the \"preferences\" node. So, 'currentParticipantRef' points to a specific user's preferences in the database.\n  const currentParticipantRef = participantRef\n    .child(userId)\n    .child(\"preferences\");\n  // schedules an update to the user's preferences in the database. The 'setTimeout' function is used here, but it doesn't introduce any significant delay. It's often used to ensure that the update happens asynchronously and doesn't block the main thread. Once the timeout is reached (which happens almost immediately), the '.update(preference)' method is called on 'currentParticipantRef' to update the user's preferences with the provided preference data.\n  setTimeout(() => {\n    currentParticipantRef.update(preference);\n  });\n};\n\n// Responsible for creating and sending an offer for a peer-to-peer connection.\n\n// Define and export a function named 'createOffer'. It takes three parameters: 'peerConnection' (an instance of a WebRTC peer connection), 'receiverId' (the ID of the receiver), and 'createdID' ( the ID of the user creating the offer).\nexport const createOffer = async (peerConnection, receiverId, createdID) => {\n  // It gets a reference (currentParticipantRef) to a specific participant (receiver) in the Firebase Realtime Database using 'participantRef'.\n  const currentParticipantRef = participantRef.child(receiverId);\n  // seting up an event handler for the 'onicecandidate' event of the peerConnection. When an ICE candidate is generated during the connection negotiation process, this event handler is called.\n  peerConnection.onicecandidate = (event) => {\n  // event.candidate && ...: It checks if there is an ICE candidate in the event. ICE candidates are pieces of information used for establishing a connection. If an ICE candidate exists, the code proceeds.\n  // currentParticipantRef.child(\"offerCandidates\").push({ ... }): It pushes the ICE candidate data (converted to JSON format) along with the userId (the ID of the user creating the offer) to a location in the Firebase Realtime Database under the \"offerCandidates\" node for the receiver. This allows the receiver to collect and use the ICE candidates to establish a connection.\n    event.candidate &&\n      currentParticipantRef\n        .child(\"offerCandidates\")\n        .push({ ...event.candidate.toJSON(), userId: createdID });\n  };\n\n  // creating an offer description using the 'createOffer' method of the peerConnection. Offers are part of the WebRTC negotiation process and contain information about the user's media capabilities and preferences.\n  const offerDescription = await peerConnection.createOffer();\n  // setting the locally generated offer description as the local description of the peerConnection. This local description will be used during the negotiation process.\n  await peerConnection.setLocalDescription(offerDescription);\n  // An object 'offer' that contains information about the offer, including the SDP (Session Description Protocol) data and the type of the offer is created.\n  const offer = {\n    sdp: offerDescription.sdp,\n    type: offerDescription.type,\n    userId: createdID,\n  };\n  // Pushing the offer data to the Firebase Realtime Database under the \"offers\" node for the receiver. This allows the receiver to retrieve the offer and initiate the connection negotiation process.\n  await currentParticipantRef.child(\"offers\").push().set({ offer });\n};\n\n\n// To handle the exchange of WebRTC offers, answers, and ICE candidates between participants\nexport const initializeListensers = async (userId) => {\n\n  // geting a reference (currentUserRef) to the current user's data in the Firebase Realtime Database using the userId.\n  const currentUserRef = participantRef.child(userId);\n  // sets up an event listener for the \"child_added\" event on the \"offers\" node under the current user's data in the database. When a new child (offer) is added to this node, the provided callback function is executed.\n  currentUserRef.child(\"offers\").on(\"child_added\", async (snapshot) => {\n    // extracting the data from the added child (offer).\n    const data = snapshot.val();\n    // if the data contains an \"offer\" \n    if (data?.offer) {\n      // It retrieves the peerConnection object associated with the user who sent the offer from the Redux store.\n      const pc = store.getState().participants[data.offer.userId].peerConnection;\n      // 'await pc.setRemoteDescription(new RTCSessionDescription(data.offer));': It sets the remote description of the peerConnection using the offer data. This is an important step in the WebRTC connection establishment process.\n      await pc.setRemoteDescription(new RTCSessionDescription(data.offer));\n      // await createAnswer(data.offer.userId, userId);: It calls the createAnswer function to create an answer for the received offer. The data.offer.userId represents the ID of the user who sent the offer, and userId represents the current user's ID.\n      await createAnswer(data.offer.userId, userId);\n    }\n  });\n\n  // Listens for incoming ICE candidates from other users, identifies the intended recipient (based on the \"userId\" property), and adds the candidate to the appropriate user's WebRTC peer connection.\n  // seting up a Firebase Realtime Database event listener that listens for new child nodes being added to the \"offerCandidates\" node under the current user's reference (currentUserRef).\n  currentUserRef.child(\"offerCandidates\").on(\"child_added\", (snapshot) => {\n    //  It retrieves the data stored in the newly added child node using the snapshot.val() method. This data typically represents an ICE candidate\n    const data = snapshot.val();\n    //If the retrieved data contains a \"userId\" property. This property is used to identify which user the ICE candidate is intended for.\n    if (data.userId) {\n      // If the \"userId\" property is present in the data, it retrieves the peerConnection object associated with the user who sent this ICE candidate. It does this by accessing the Redux store's 'getState()' method to obtain the current state, then navigating through the \"participants\" object to find the relevant user's 'peerConnection'.\n      const pc = store.getState().participants[data.userId].peerConnection;\n      // Adding the ICE candidate (represented by the data object) to the user's peer connection (pc) using the addIceCandidate method. This step is crucial for establishing a WebRTC connection, as ICE candidates contain network information necessary for peers to find and communicate with each other.\n      pc.addIceCandidate(new RTCIceCandidate(data));\n    }\n  });\n\n  // Listens for incoming answers from other users, extracts the answer data, identifies the intended recipient (based on the \"userId\" property), and sets the remote description of the user's WebRTC peer connection to establish a bidirectional communication channel. \n  // seting up a Firebase Realtime Database event listener that listens for new child nodes being added to the \"answers\" node under the current user's reference (currentUserRef).\n  currentUserRef.child(\"answers\").on(\"child_added\", (snapshot) => {\n    // Retrieving the data stored in the newly added child node using the snapshot.val() method. This data typically represents an answer to a WebRTC offer.\n    const data = snapshot.val();\n    // It checks if the retrieved data contains an \"answer\" property. This property is used to identify that this child node contains answer data.\n    if (data?.answer) {\n    // If the \"answer\" property is present in the data, it retrieves the peerConnection object associated with the user who sent this answer. It does this by accessing the Redux store's getState() method to obtain the current state, then navigating through the \"participants\" object to find the relevant user's peerConnection. The \"userId\" property of the answer data is used to identify the user.\n      const pc = store.getState().participants[data.answer.userId].peerConnection;\n      // Creating a new RTCSessionDescription object based on the answer data received from the database. This object represents the remote description of the peer connection, which includes the session description protocol (SDP) information.\n      const answerDescription = new RTCSessionDescription(data.answer);\n      // setting the remote description of the user's peer connection (pc) to the answer description using the setRemoteDescription method. This step is crucial in the WebRTC connection setup process because it informs the peer's connection about the parameters and configuration of the remote stream.\n      pc.setRemoteDescription(answerDescription);\n    }\n  });\n\n  // Listens for incoming ICE candidates from other users, extracts the candidate data, identifies the intended recipient (based on the \"userId\" property), and adds the ICE candidate to the user's WebRTC peer connection. \n  // setting up a Firebase Realtime Database event listener that listens for new child nodes being added to the \"answerCandidates\" node under the current user's reference (currentUserRef).\n  currentUserRef.child(\"answerCandidates\").on(\"child_added\", (snapshot) => {\n    //  retrieves the data stored in the newly added child node using the snapshot.val() method. This data typically represents an ICE candidate used for establishing a WebRTC connection.\n    const data = snapshot.val();\n    // If the retrieved data contains a \"userId\" property. This property is used to identify which user the ICE candidate is intended for.\n    if (data.userId) {\n    // If the \"userId\" property is present in the data, it retrieves the peerConnection object associated with the user who is supposed to receive this ICE candidate. It does this by accessing the Redux store's getState() method to obtain the current state, then navigating through the \"participants\" object to find the relevant user's 'peerConnection'.\n      const pc = store.getState().participants[data.userId].peerConnection;\n    // Adding the ICE candidate to the user's peer connection (pc) using the 'addIceCandidate' method. ICE candidates are crucial for establishing direct communication between peers in a WebRTC connection. They contain network information necessary for the peer-to-peer connection setup.\n      pc.addIceCandidate(new RTCIceCandidate(data));\n    }\n  });\n};\n\n// 'createAnswer' is responsible for creating an answer in response to an offer from another user. It sets up ICE candidate handling, generates the answer, stores it in the Firebase Realtime Database, and prepares the local description for the WebRTC connection. This process is crucial for establishing bidirectional communication in a WebRTC application.\n// It takes two parameters: otherUserId (the ID of the user for whom we are creating an answer) and userId (the ID of the current user).\nconst createAnswer = async (otherUserId, userId) => {\n  // It retrieves the peerConnection object associated with the other user (the user who sent the offer) from the Redux store's state. This peerConnection is essential for creating the answer.\n  const pc = store.getState().participants[otherUserId].peerConnection;\n  // It gets a reference to the Firebase Realtime Database location specific to the other user (the user who sent the offer). This reference will be used to store answer-related information.\n  const participantRef1 = participantRef.child(otherUserId);\n  // Setting up an event listener on the peerConnection for ICE candidate events. When an ICE candidate event occurs (indicating the availability of an ICE candidate), it executes the provided callback function\n  pc.onicecandidate = (event) => {\n    // Inside the callback function, it checks if the event object contains a valid ICE candidate (event.candidate). If a valid candidate exists, it proceeds to the next step. It pushes the ICE candidate data (converted to JSON) into the \"answerCandidates\" location under the other user's reference in the Firebase Realtime Database. This allows the other user to access and use this ICE candidate for establishing the WebRTC connection.\n    event.candidate &&\n      participantRef1\n        .child(\"answerCandidates\")\n        .push({ ...event.candidate.toJSON(), userId: userId });\n  };\n\n  // It sets the locally generated answer description as the local description of the peerConnection. This step is necessary to prepare the answer for transmission.\n  const answerDescription = await pc.createAnswer();\n  await pc.setLocalDescription(answerDescription);\n  // It constructs an answer object containing the answer's type, SDP, and the userId of the current user.\n  const answer = {\n    type: answerDescription.type,\n    sdp: answerDescription.sdp,\n    userId: userId,\n  };\n\n  // It pushes the answer object into the \"answers\" location under the other user's reference in the Firebase Realtime Database. It pushes the answer object into the \"answers\" location under the other user's reference in the Firebase Realtime Database.\n  await participantRef1.child(\"answers\").push().set({ answer });\n};\n\n\n\n\n\n\n/* \n                                              *********** Summary *********** \n\nFirebase Database Structure:\n\n- root\n  - conference_1\n    - participants\n      - userId_1\n        - preferences\n        - offers\n        - offerCandidates\n        - answers\n        - answerCandidates\n      - userId_2\n        - preferences\n        - offers\n        - offerCandidates\n        - answers\n        - answerCandidates\n      ...\n  - conference_2\n    - participants\n      - userId_3\n        - preferences\n        - offers\n        - offerCandidates\n        - answers\n        - answerCandidates\n      - userId_4\n        - preferences\n        - offers\n        - offerCandidates\n        - answers\n        - answerCandidates\n      ...\n  ...\n-> The root represents the root of the Firebase Realtime Database.\n-> firepadRef is a reference to a specific location in the database, and it serves as the root for all video conference-related data.\n-> participants is a node under firepadRef where information about conference participants is stored. Each participant is identified by their unique userId.\n-> For each participant (userId_x), the following sub-nodes are present:\n      preferences: Stores participant preferences.\n      offers: Stores offers sent by the participant.\n      offerCandidates: Stores ICE candidates related to the participant's offer.\n      answers: Stores answers received by the participant.\n      answerCandidates: Stores ICE candidates related to the participant's answer.\n-> These nodes are used to manage and exchange WebRTC-related data, including offers, answers, ICE candidates, and participant preferences during a video conference. Firebase Realtime Database provides a structured and real-time data synchronization mechanism for this purpose.\n\n\n\n-> Peer Connection Setup: A new RTCPeerConnection object called peerConnection is created to represent the connection between the local user and a remote user.\n\n-> ICE Candidate Handling: Event listeners for ICE candidates are set up. These ICE candidates are crucial for the negotiation of network routes between the local and remote users. When ICE candidates are generated during the connection process, event handlers are ready to manage them.\n\n-> Adding Local Stream: The local user's audio and video streams, represented by the localStream object, are added to the peerConnection. This step allows the local user's audio and video data to be transmitted to the remote user.\n\n-> Offer Creation and Sending: An offer, containing session description protocol (SDP) information, is created locally. This offer describes the local user's audio and video capabilities and preferences. The local user sets this offer as its local description.\n\n-> Signaling Mechanism: The local user sends this offer to the remote peer through a signaling mechanism. This mechanism can be a server, a messaging system, or any method for transmitting data between the two users.\n\n-> Offer Reception and Remote Description Set: On the remote side, the offer is received and processed. A remote session description is created based on the offer's SDP information. This remote description is set as the remote peer's description.\n\n-> Handling ICE Candidates from Remote Peer: Additionally, ICE candidates received from the remote peer are handled. These candidates help establish direct network connections and are added to the peerConnection.\n\n-> Remote Answer Generation and Sending: After receiving the offer, the remote peer generates an answer. This answer describes the remote user's audio and video capabilities and preferences. The remote peer sends this answer back to the local user.\n\n-> Remote Answer Processing: The local user receives the remote answer and sets it as the remote description in its peerConnection.\n\n-> Connection Established: With both local and remote descriptions set, the WebRTC connection is established, allowing real-time audio and video communication between the local and remote users.\n\n* In summary, this systematic approach ensures that both users in the call exchange session descriptions (offer and answer) and ICE candidates to establish a direct and efficient communication channel for audio and video data, enabling a seamless video call experience.\n\n\n\n\n*/\n","// Reducer manages the application's state for video conferencing, including adding and removing participants, handling user preferences, and establishing WebRTC connections for real-time communication.\nimport {\n  SET_MAIN_STREAM,\n  ADD_PARTICIPANT,\n  SET_USER,\n  REMOVE_PARTICIPANT,\n  UPDATE_USER,\n  UPDATE_PARTICIPANT,\n} from \"./actiontypes\";\n\nimport {\n  createOffer,\n  initializeListensers,\n  updatePreference,\n} from \"../server/peerConnection\";\n\n/* \ndefaultUserState is an object that represents the initial or default state of your application. It includes three main properties:\n  mainStream: This property is initially set to null, indicating that there is no main video stream defined when the application starts.\n  participants: This property is an empty object ({}), indicating that there are no participants in the video conference initially.\n  currentUser: This property is initially set to null, indicating that there is no current user defined when the application starts.\n*/\nlet defaultUserState = {\n  mainStream: null,\n  participants: {},\n  currentUser: null,\n};\n\n// 'servers' is an object that contains configuration settings for ICE (Interactive Connectivity Establishment) servers. ICE servers are used in WebRTC (Web Real-Time Communication) to establish peer-to-peer connections between users for real-time communication.\nconst servers = {\n  // iceServers: This property is an array of server configurations. In this case, it specifies a list of STUN (Session Traversal Utilities for NAT) servers provided by Google and Mozilla. STUN servers are used to discover a client's public IP address and port when it is located behind a NAT (Network Address Translation) firewall.\n  iceServers: [\n    {\n      urls: [\n        \"stun:stun.l.google.com:19302\",\n        \"stun:global.stun.twilio.com:3478\",\n        \"stun:stun1.l.google.com:19302\",\n        \"stun:stun2.l.google.com:19302\",\n        \"stun:stun.l.google.com:19302\",\n        \"stun:stun3.l.google.com:19302\",\n        \"stun:stun4.l.google.com:19302\",\n        \"stun:stun.services.mozilla.com\",\n      ],\n    },\n  ],\n  // iceCandidatePoolSize: This property sets the maximum number of ICE candidates that can be stored. ICE candidates are network endpoints used in the connection process.\n  iceCandidatePoolSize: 10,\n  // The iceCandidatePoolSize property helps manage the number of potential network paths (ICE candidates) between two users during the WebRTC connection setup. During the WebRTC connection setup process, ICE candidates are generated. These candidates represent different network paths that can be used for communication. However, generating and managing a large number of candidates can consume memory and resources.\n};\n\n// 'generateColor' generates a random color code in the format #RRGGBB, where RR, GG, and BB are two-digit hexadecimal values representing the red, green, and blue components of the color, respectively. This function is commonly used to assign random colors to elements in a UI, like avatars or user interface elements, for visual distinction.\nconst generateColor = () =>\n  \"#\" + Math.floor(Math.random() * 16777215).toString(16);\n\n\n// 'userReducer' is Redux reducer which is responsible for managing the state related to users and video conference participants. It handles various actions dispatched by the application to update this state.\n// 'userReducer' function listens for specific action types and updates the user-related state accordingly. It uses the payload from actions to make these updates. This reducer handles actions related to managing participants, the current user, and the main video stream in a video conference application.\n// The 'userReducer' function, which takes two parameters: state (the current state, initialized with defaultUserState) and action (the action object dispatched to update the state).\nexport const userReducer = (state = defaultUserState, action) => {\n  //  If the action.type is equal to SET_MAIN_STREAM. It is the action type used to set the main video stream in the application.\n  if (action.type === SET_MAIN_STREAM) {\n  // extracting the 'payload' object from the action. The payload typically contains data to be used when updating the state.\n    let payload = action.payload;\n  // creating a new state object by spreading the properties of the current state (...state) and then spreading the properties of the payload object (...payload). This is a way to merge the changes from the payload into the current state.\n    state = { ...state, ...payload };\n  // returning the updated state after setting the main video stream.\n    return state;\n  } \n  //  when the action type is ADD_PARTICIPANT. It's responsible for adding a new participant to the video conference.\n  else if (action.type === ADD_PARTICIPANT) {\n    // The payload object from the action is extracted and assigned to the payload variable. This payload typically contains data related to the new participant being added.\n    let payload = action.payload;\n    //  Extracting the current user's ID from the state.currentUser object. This ID is used to identify the user who is currently using the application.\n    const currentUserId = Object.keys(state.currentUser)[0];\n    // extracts the new participant's ID from the payload.newUser object. It identifies the new participant being added\n    const newUserId = Object.keys(payload.newUser)[0];\n\n    // state.mainStream: It checks if there is a main video stream available in the state. If there is no main stream, it means that the video conference hasn't started yet, so there's no need to establish a connection. \n    // currentUserId !== newUserId: It checks if the new participant being added is not the same as the current user. If they are the same, there's no need to establish a connection because the user is already in the conference.\n    if (state.mainStream && currentUserId !== newUserId) {\n      // If both conditions in the if statement are met, it calls the addConnection function to establish a connection between the new participant and the main video stream. This connection setup is necessary for video conferencing.\n      payload.newUser = addConnection(\n        payload.newUser,\n        state.currentUser,\n        state.mainStream\n      );\n    }\n\n    // This conditional statement checks if the new participant being added is the same as the current user. If they are the same, it means the current user is joining the video conference, so the code does the following:\n    // payload.newUser[newUserId].currentUser = true;: It sets the currentUser property of the new user in the payload to true, indicating that this user is the current user.\n    if (currentUserId === newUserId)\n      payload.newUser[newUserId].currentUser = true;\n    // Assigning an avatar color to the new user. Each user in the video conference is assigned a unique avatar color. The generateColor function is used to generate a random color, which is then assigned to the new user.\n    payload.newUser[newUserId].avatarColor = generateColor();\n    //  A new object named participants is created by combining the existing state.participants with the new user data from the payload. This ensures that the new user is included in the list of participants.\n    let participants = { ...state.participants, ...payload.newUser };\n    //  The state is updated by spreading the existing state properties and including the updated participants object.\n    state = { ...state, participants };\n    return state;\n  } \n  // Handles the process of setting the current user in the application's state. It extracts user information from the payload, assigns an avatar color, initializes listeners, and updates the state accordingly.\n  else if (action.type === SET_USER) {\n    // A reference to the action's payload is stored in a variable named payload\n    let payload = action.payload;\n    // A copy of the existing state.participants object is made and stored in a variable named participants. This ensures that we are working with a copy of the current participants.\n    let participants = { ...state.participants };\n    // Extracting the user ID from the payload's currentUser object.\n    const userId = Object.keys(payload.currentUser)[0];\n    // Assigning an avatar color to the current user using the generateColor function. This color is unique to each user.\n    payload.currentUser[userId].avatarColor = generateColor();\n    // The purpose of the initializeListensers function is to set up event listeners related to WebRTC (Web Real-Time Communication) communication for a specific user identified by their userId.\n    /* \n      Inside the initializeListensers function, there are event listeners set up for various types of events related to WebRTC communication. These events include:\n        Listening for incoming offers from other users.\n        Listening for incoming offer candidates.\n        Listening for incoming answers from other users.\n        Listening for incoming answer candidates.\n      These event listeners are crucial for establishing and maintaining real-time audio and video communication between users in a video conferencing application.\n      When these events occur (e.g., when an offer is received from another user), the event handlers associated with these listeners will execute specific actions.\n      For example, when an offer is received, the code may create an answer and set up a peer connection to establish a video call.\n      The initializeListensers function plays a key role in managing the WebRTC communication flow for a user. It ensures that the user can receive and respond to offers, candidates, answers, and other signaling messages required for real-time communication.\n    */\n    initializeListensers(userId);\n    // The state is updated to include the current user and their avatar color.\n    // currentUser: { ...payload.currentUser }: This sets the currentUser property in the state to the data provided in the payload, including the newly assigned avatar color.\n    // participants: The participants object is updated with the new current user data.\n    state = { ...state, currentUser: { ...payload.currentUser }, participants };\n    return state;\n  } \n  //  Handles the removal of a participant from the application's state when a REMOVE_PARTICIPANT action is dispatched. It ensures that the state remains immutable, and the desired participant is removed from the participants object.\n  else if (action.type === REMOVE_PARTICIPANT) {\n    // Extracting the payload object from the action. The payload typically contains data or information necessary for the action. In this case, it may contain the id of the participant to be removed.\n    let payload = action.payload;\n    //  Createing a shallow copy of the participants object from the current state. This copy ensures that the original state remains unchanged while modifications are made.\n    let participants = { ...state.participants };\n    //  Removing a participant from the participants object using the id provided in the payload. It essentially deletes the participant's data from the state.\n    delete participants[payload.id];\n    // Here, a new state object is created by spreading the existing state (...state) and updating the participants property with the modified participants object. This follows the immutability principle in Redux, where state updates should produce a new state object.\n    state = { ...state, participants };\n    //  The updated state is returned from the reducer. Redux stores this updated state for further use.\n    return state;\n  } \n  // Handles the updating of the current user's data within the application's state when an UPDATE_USER action is dispatched. It ensures that the state remains immutable, and the user's data is updated as specified in the payload.\n  else if (action.type === UPDATE_USER) {\n    // Extracting the payload object from the action. The payload typically contains data or information necessary for the action. In this case, it may contain updates to the current user's data.\n    let payload = action.payload;\n    // Extracting the ID of the current user from the currentUser object in the state. In Redux, the current user's data is often stored under the currentUser property.\n    const userId = Object.keys(state.currentUser)[0];\n    // updatePreference(userId, payload.currentUser);: Invokes the updatePreference function, passing the userId and the currentUser object from the payload as arguments. It's responsible for updating the user's preferences, possibly related to audio, video, or other settings.\n    updatePreference(userId, payload.currentUser);\n    // state.currentUser[userId] = { ...state.currentUser[userId], ...payload.currentUser };: It updates the current user's data within the state. This update involves spreading the existing user data (...state.currentUser[userId]) and merging it with the data from the payload (...payload.currentUser). This ensures that the user's data is updated without mutating the state directly.\n    state.currentUser[userId] = {\n      ...state.currentUser[userId],\n      ...payload.currentUser,\n    };\n    // state = { ...state, currentUser: { ...state.currentUser } };: Creates a new state object that spreads the existing state (...state) and ensures that the currentUser property is also copied. This step follows the immutability principle in Redux, where state updates should produce a new state object.\n    state = {\n      ...state,\n      currentUser: { ...state.currentUser },\n    };\n    // The updated state is returned from the reducer. Redux stores this updated state for further use.\n    return state;\n  } \n  // Handles the updating of participant data within the application's state when an UPDATE_PARTICIPANT action is dispatched. It ensures that the state remains immutable, and the participant's data is updated as specified in the payload.\n  else if (action.type === UPDATE_PARTICIPANT) {\n    // Extracting the payload object from the action. The payload typically contains data or information necessary for the action. In this case, it may contain updates to a participant's data\n    let payload = action.payload;\n    // Extracting the ID of the new participant from the newUser object in the payload. This ID is used to identify the participant being updated.\n    const newUserId = Object.keys(payload.newUser)[0];\n    // Updating the data of the participant with the ID newUserId. It spreads the existing participant data (...state.participants[newUserId]) and merges it with the data from the payload (...payload.newUser[newUserId]). This ensures that the participant's data is updated without mutating the state directly.\n    payload.newUser[newUserId] = {\n      ...state.participants[newUserId],\n      ...payload.newUser[newUserId],\n    };\n    // Creating a new participants object that spreads the existing participants (...state.participants) and merges it with the data from the payload (...payload.newUser). This step combines the updated participant data with the existing participants in the state.\n    let participants = { ...state.participants, ...payload.newUser };\n    // Creating a new state object that spreads the existing state (...state) and updates the participants property with the newly combined participants object. This step follows the immutability principle in Redux, where state updates should produce a new state object.\n    state = { ...state, participants };\n    //  The updated state is returned from the reducer. Redux stores this updated state for further use.\n    return state;\n  }\n  // If none of the conditions match (else block), the original state is returned.\n  return state;\n};\n\n// Responsible for setting up a new WebRTC peer connection for a participant (the new user) and adding their audio and video tracks to it. It also determines the roles of offerer and answerer based on user IDs and, if needed, initiates the offer creation process. The updated participant data is returned as an object.\nconst addConnection = (newUser, currentUser, stream) => {\n  // Creating a new WebRTC peer connection (RTCPeerConnection) using the configuration defined in the servers object. This connection is used for real-time communication with other participants in the video conference.\n  const peerConnection = new RTCPeerConnection(servers);\n  // Iterating through all tracks in the stream object (which typically represents the user's audio and video streams) and adds each track to the peerConnection. This step establishes the media streams for communication.\n  stream.getTracks().forEach((track) => {\n    peerConnection.addTrack(track, stream);\n  });\n\n  // Extracting the user IDs of the new user and the current user. They also sort the IDs to determine the order of creating offers and answers. The user with the lower ID becomes the offerer, and the other becomes the answerer.\n  const newUserId = Object.keys(newUser)[0];\n  const currentUserId = Object.keys(currentUser)[0];\n\n  const offerIds = [newUserId, currentUserId].sort((a, b) =>\n    a.localeCompare(b)\n  );\n\n  // Setting the peerConnection property for the new user within the newUser object. This property holds the reference to the WebRTC peer connection created for the new user.\n  newUser[newUserId].peerConnection = peerConnection;\n  // If the new user is the offerer (determined by the order of their user IDs), this block calls the createOffer function to create and send an offer to the other participant (the answerer). This offer is a critical step in the WebRTC handshake process.\n  if (offerIds[0] !== currentUserId)\n    createOffer(peerConnection, offerIds[0], offerIds[1]);\n  // returning the updated newUser object, which now includes the peerConnection property and may have initiated the offer creation process.\n  return newUser;\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport { Provider } from \"react-redux\";\nimport { createStore } from \"redux\";\nimport { userReducer } from \"./store/reducer\";\n\n// Create a Redux Store: The code creates a Redux store using the createStore function from Redux. It passes the userReducer to the store, which will handle state updates based on various actions.\nexport const store = createStore(userReducer);\n/*\nReactDOM.render(): This function is used to render the React application into the HTML DOM. It takes the following parameters:\n\n-> <React.StrictMode>: This is a wrapper component used for highlighting potential problems in the application during development. It doesn't affect the production build.\n-> <Provider store={store}>: This is a higher-order component provided by React Redux. It wraps the entire application and provides access to the Redux store to all components within the application. The store prop is set to the Redux store we created earlier.\n-> <App />: This is the main component of the application, and it represents the root of the React component tree.\n-> document.getElementById(\"root\"): This specifies the DOM element where the React application should be rendered. In this case, it looks for an element with the ID \"root\" in the HTML file.\n*/\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n// reportWebVitals(): This is a function that reports various web vitals metrics for performance monitoring. It's provided by Create React App and helps developers identify performance issues.\nreportWebVitals();\n"],"sourceRoot":""}